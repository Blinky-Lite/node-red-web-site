{"0": {
    "doc": "Access Log App",
    "title": "Access Log",
    "content": "The access log displays the date and IP address of HTTP connection requests to the application server. This application is available to users who have the appropriate administration privilege. ",
    "url": "/pages/Overview/accessLogAppPreview.html#access-log",
    
    "relUrl": "/pages/Overview/accessLogAppPreview.html#access-log"
  },"1": {
    "doc": "Access Log App",
    "title": "Access Log App",
    "content": " ",
    "url": "/pages/Overview/accessLogAppPreview.html",
    
    "relUrl": "/pages/Overview/accessLogAppPreview.html"
  },"2": {
    "doc": "Alarm Scanner App",
    "title": "Alarm Scanner",
    "content": "The alarm scanner app displays a list of cubes that are outside the alarm block limits. Only trays that the user has access are shown for an given user. The user can also change the cube setting if the user has setting permissions. In addition, the user can also edit the alarm block of an individual cube. Sample Alarm Scanner . Sample Alarm Scanner config Dialog . ",
    "url": "/pages/Overview/alarmScannerAppPreview.html#alarm-scanner",
    
    "relUrl": "/pages/Overview/alarmScannerAppPreview.html#alarm-scanner"
  },"3": {
    "doc": "Alarm Scanner App",
    "title": "Alarm Scanner App",
    "content": " ",
    "url": "/pages/Overview/alarmScannerAppPreview.html",
    
    "relUrl": "/pages/Overview/alarmScannerAppPreview.html"
  },"4": {
    "doc": "App Authentication",
    "title": "App Authentication",
    "content": "For security, all Blinky-LiteTM applications require user authentication. User credentials are stored in the application database. The credentials can be configured to be either a name-password pair or a name-one time password pair with two factor authentication. It is highly recommended to use the two factor authentication method. Blinky-LiteTM two factor authentication works well with any onetime password app such as Google Authenticator or Authy. Blinky-LiteTM insures that all web applications are served over an SSL connection. Once authenticated, Blinky-LiteTM checks all client requests with JSON Web Tokens (JWT). ",
    "url": "/pages/Overview/appAuthentication.html",
    
    "relUrl": "/pages/Overview/appAuthentication.html"
  },"5": {
    "doc": "App Authentication",
    "title": "OTP Login",
    "content": ". ",
    "url": "/pages/Overview/appAuthentication.html#otp-login",
    
    "relUrl": "/pages/Overview/appAuthentication.html#otp-login"
  },"6": {
    "doc": "App Authentication",
    "title": "Credential page for OTP setup",
    "content": ". ",
    "url": "/pages/Overview/appAuthentication.html#credential-page-for-otp-setup",
    
    "relUrl": "/pages/Overview/appAuthentication.html#credential-page-for-otp-setup"
  },"7": {
    "doc": "App Authentication",
    "title": "QR-Code for OTP setup with authentication app.",
    "content": ". ",
    "url": "/pages/Overview/appAuthentication.html#qr-code-for-otp-setup-with-authentication-app",
    
    "relUrl": "/pages/Overview/appAuthentication.html#qr-code-for-otp-setup-with-authentication-app"
  },"8": {
    "doc": "Application Builder",
    "title": "Application Builder",
    "content": "The Cube Explorer app is an all purpose app for displaying and setting data in the control system. However, sometimes, the user would like to build a consist custom dashboard application. Building event driven controls applications can be quite complicated so Blinky-LiteTM has an application builder that makes it easy for the user to build his own custom dashboard application without having to do any programming. The user just configures a JSON file. The application builder has a basic library of widgets based on Boostrap 4 cards. This widget library is easily extensible to more widgets. The widgets are configured with a JSON object that is stored in the Blinky-LiteTM database as shown in the widget examples. ",
    "url": "/pages/Overview/appBuilderPreview.html",
    
    "relUrl": "/pages/Overview/appBuilderPreview.html"
  },"9": {
    "doc": "Application Builder",
    "title": "Application Builder Examples",
    "content": "| Example 1 | Example 2 | . | | | . ",
    "url": "/pages/Overview/appBuilderPreview.html#application-builder-examples",
    
    "relUrl": "/pages/Overview/appBuilderPreview.html#application-builder-examples"
  },"10": {
    "doc": "Application Builder",
    "title": "Application Builder Widget Library",
    "content": "| Widget | Example | Configuration | . | Nav Bar | | | . | Number Read | | | . | Number Set | | | . | On-Off | | | . | Image Reading | | | . | State Choice | | | . | Gauge | | | . | Horz. Bar | | | . | Archive | | | . | Time Plot | | | . | Iframe | | | . | User | | | . ",
    "url": "/pages/Overview/appBuilderPreview.html#application-builder-widget-library",
    
    "relUrl": "/pages/Overview/appBuilderPreview.html#application-builder-widget-library"
  },"11": {
    "doc": "App Overview",
    "title": "Blinky-LiteTM App Overview",
    "content": "Out of the box, Blinky-LiteTM provides a comprehensive suite of applications. Since there is no need to add 3rd party solutions or external custom scripts (such as the ubiquitous python scripts infesting many other control systems), the Blinky-LiteTM architecture is self-contained, hence more reliable and secure. ",
    "url": "/pages/Overview/appOverview.html#blinky-litetm-app-overview",
    
    "relUrl": "/pages/Overview/appOverview.html#blinky-litetm-app-overview"
  },"12": {
    "doc": "App Overview",
    "title": "App Overview",
    "content": " ",
    "url": "/pages/Overview/appOverview.html",
    
    "relUrl": "/pages/Overview/appOverview.html"
  },"13": {
    "doc": "Application Server",
    "title": "Application Server",
    "content": "The Application Server (or Blinky-Lite Box) requires MongoDB and MQTT as services which can be difficult to install so we have bundled the Blinky-Lite Box in a Docker container. Then we have developed Docker Compose yaml files for retrieving and starting the Blinky-Lite Box with all the required services. The Docker Engine is easily installed on Linux systems. For operating systems other than Linux you will need to use Docker Desktop. Usage . Download zipped blinky-lite-box docker compose file template. The file will unzip into a directory. Enter the directory and edit the .env file with settings of your choosing. Environment Variables . | BLINKYLITE_PASSWORD - password for the MongoDB database | JWTKEYSECRET - key for the JWT security | NEXMOAPIKEY - Vonnage sms API key1 | NEXMOAPISECRET - Vonnage sms API secret1 | MAXDBSIZE - Maximum size of the MongoDB database in bytes | BLINKYPORT - IP port of the Blinky-Lite Web application | EXPRESSPORT - IP port of the MongoDB Express Web application | MQTTPORT - IP port of MQTT communications which is usually set to 1883 | TWOFA - Two factor authentication flag, 0 for disable, 1 for enable | ENABLEARCHIVE - Enable archiving flag. 0 for disable, 1 for enable | . Starting the containers . From a command line, enter the blinky-box-docker directory that you just unzipped and enter: . docker compose -f blinky-box.yaml up -d . On the first run, Docker will have to pull a number of images that will take some time. Once the containers have spun up you can see the Blinky-Lite application and the database application on localhost on the ports specified in the .env file. Adding MQTT Passwords . The script add-mqtt-pw.sh can be used for adding mqtt credentials. The usage is: ./add-mqtt-pw.sh &lt;username&gt; &lt;password&gt; . This script will restart the MQTT container to load the new credentials. To remove passwords, edit the pwfile in the mqtt-auth folder and then restart the mqtt container with the restart-mqtt.sh script. To restart the MQTT container, go to a command line in the blinky-box-docker directory and enter: ./restart-mqtt-pw.sh . Adding MQTT Access Control List (ACL) Rules . In the mqtt-auth folder, edit the aclfile file. There are examples already in place. After editing the file, restart the mqtt container with the restart-mqtt.sh script as descirbed above. ",
    "url": "/pages/Installation/appServerInstall.html",
    
    "relUrl": "/pages/Installation/appServerInstall.html"
  },"14": {
    "doc": "Application Server",
    "title": "Customization",
    "content": "Blinky-Lite is fully customize-able. The home page of a Blinky-Lite box is a static web page the and is defined in the index.html file and the homepage folder inside the blinky-box-docker directory. Icons used in the Blinky-Lite applications can also be customized in the blinky-lite-icons folder inside the blinky-box-docker directory. Most of the Blinky-Lite Box services are customized by editing the database. This can easily be done with the Mongo-Express server that was installed in the Docker Compose file that can be accessed at http://localhost:xxxxx where xxxxx is defined by the EXPRESSPORT environmental variable. The username for the Mongo-Express server is admin and the password is defined by the BLINKYLITE_PASSWORD environmental variable. ",
    "url": "/pages/Installation/appServerInstall.html#customization",
    
    "relUrl": "/pages/Installation/appServerInstall.html#customization"
  },"15": {
    "doc": "Application Server",
    "title": "Accessing the Application Server",
    "content": "The home page for the Application Server is at http://localhost:yyyyy where yyyyy is defined by the BLINKYPORT environmental variable. You can access the application index page at http://localhost:yyyyy/myapps. The Docker image comes loaded with an example user aeinstein with a password e=mcsquared. You should delete this example user after you have deployed the application server. | Blinky-Lite uses Nexmo or Vonnage for SMS alerts. It you do not have an SMS account with Vonnage, then leave the Nexmo variables alone. &#8617; &#8617;2 . | . ",
    "url": "/pages/Installation/appServerInstall.html#accessing-the-application-server",
    
    "relUrl": "/pages/Installation/appServerInstall.html#accessing-the-application-server"
  },"16": {
    "doc": "Architecture",
    "title": "Blinky-LiteTM Architecture",
    "content": ". | Blinky-LiteTM Architecture . | The Application Box . | The MQTT Broker | The Application Server | The Database Server | . | Message Trays | Cube Controllers | . | . The Blinky-LiteTM Architecture consists of three major components: . | Application Box | Message Trays | Controller Cubes | . Fig. 1 Blinky-Lite Architecture . ",
    "url": "/pages/Overview/architecture.html#blinky-litetm-architecture",
    
    "relUrl": "/pages/Overview/architecture.html#blinky-litetm-architecture"
  },"17": {
    "doc": "Architecture",
    "title": "The Application Box",
    "content": "The Application Box is comprised of three services, the MQTT Broker, the Application Server, and the Database Server. Each of these three services can be hosted on the same computer inside a firewall or on the cloud, or each service can be hosted on its own computer inside a firewall or on the cloud. For reliability and ease of installation, the preferred method is to have each service hosted own its own machine in the cloud. | The MQTT Broker . The MQTT broker provides:. | Communication exchange The communication protocol for Blinky-LiteTM is MQTT. MQTT uses a publish-subscribe paradigm. The MQTT Broker relays messages between message trays and the Application Server. For prompt communications, the MQTT broker can also relay messages directly between message trays without having to go through the Application Server | Data Pooling Because of the publish-subscribe paradigm, The MQTT broker effectively protects the message trays from being overloaded from too many communication requests from the Application Server. | Security The MQTT broker acts an additional layer of security because both the message trays and Application Server must authenticate to the MQTT broker to pass messages. Since the message tray must initiate the connection to the MQTT Broker, this eliminates the need for external SSH tunnels into your private network for remote access. Finally, the MQTT Broker can be easily configured to only accept specific and unique topics to and from each message tray adding another layer of security. | . | The Application Server . The Application Server tasks are: . | Alarm Scanning The Application Server collects messages from the message trays via the MQTT Broker scans for alarms and routes these alarms to user alarm applications and the SMS messenger | Data Archival The Application Server routes the messages from the message trays to the database server for status update and archival. | User application server The Application Server also hosts the user applications. The Application Server checks user requests via role-based access routing and and routes the requests to the appropriate message trays and database server. The application server is written using the Node-RED programming environment. Node-RED makes it easy: . | to read, edit, and document the code | for the user to change the code | to version control the code | to port the code to other machines | . Fig. 2 Node-RED Programming Environment . | . | The Database Server . Instead of using name-value pairs for describing the data as with most other control system platforms, Blinky-LiteTM uses a class structure to describe systems in the message trays. This structure makes communicating between subsystems and data archival much more streamlined and easy to read and modify. The data in the class structure is stored in JSON objects which is a common lightweight data-interchange format ideal for communicating with mobile browser-based web applications. Most of the data in the control system is time-sequenced so a non-SQL type of database such as MongoDB or RethinkDB is much easier to configure and use. Currently, Blinky-LiteTM is configured to interface smoothly with a MongoDB database.1 . The database is divided into collections of JSON object documents to not only handle data archiving but other services as well such as access logs and app configurations. The list of collections in a Blinky-LiteTM project is: . | trays - tray configuration | archiver - tray data archiving | users - list of users, their credentials, and their roles | appConfig - configurations for the standard applications | appStyleSheets - custom CSS sheets for the standard applications | accessLog - record of all visits to the project | settingsLog - record of all tray settings made in the project | restAccessLog - record of all RESTful interface visits to the project | . | . ",
    "url": "/pages/Overview/architecture.html#the-application-box",
    
    "relUrl": "/pages/Overview/architecture.html#the-application-box"
  },"18": {
    "doc": "Architecture",
    "title": "Message Trays",
    "content": "The concept of message trays is what makes Blinky-LiteTM truly versatile. The message trays communicate to a device using whatever protocol and hardware is supported by the device, such as Modbus, serial (UART, SPI, I2C, etc.), RS232, MQTT, etc. The message tray packages the device information into a Blinky-LiteTM Tray JSON object in a standard format that is discussed in [Need REF!]. The tray message is then published to the Application Box MQTT broker. Since the Application Server subscribes to all the message tray topics in a Blinky-LiteTM project, the Application Server will receive this message. In this way, the applications on the Application Server can be standardized and reused from project to project. Also, any other tray that subscribes to the message tray’s unique topic can also receive the tray’s JSON object. The message tray can also subscribe to other message tray topics or messages sent from the Application Server. These messages can the be used to alter the state of the tray or devices the tray is connected to. As shown in Figure 1, more than one device can be connected to a single tray. Thus, the tray can function as a micro-control system in a truly Edge computing manner. Each message tray runs as a separate Node-RED flow. Usually, there is only a single tray flow running on a single Node-RED process running on a microcomputer such as a Raspberry Pi. However, it is also possible to run multiple tray flows on a single Node-RED instance running on a computer other than a Raspberry Pi, such as computer in the cloud. Local and cloud trays are discussed in [Need Ref!] . ",
    "url": "/pages/Overview/architecture.html#message-trays",
    
    "relUrl": "/pages/Overview/architecture.html#message-trays"
  },"19": {
    "doc": "Architecture",
    "title": "Cube Controllers",
    "content": "Cube controllers are not necessarily required in a Blinky-LiteTM project. For example, if the device is a Modbus device, then the tray can be directly connected to the device. An example ModBus tray can be found in [Need Ref!]. If the device is, for example, a stepper motor, then some hardware is required to interface the motor to translate tray commands. This is usually done through a micro-controller such as an Arduino, Teensy, or Raspberry Pi Pico. We have developed a number of serial and MQTT interfaces to micro-controllers that can be found at [Needs Ref!]. | MongoDB is not open-source software so the user must provide their own instance of a MongoDB database server. &#8617; . | . ",
    "url": "/pages/Overview/architecture.html#cube-controllers",
    
    "relUrl": "/pages/Overview/architecture.html#cube-controllers"
  },"20": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": " ",
    "url": "/pages/Overview/architecture.html",
    
    "relUrl": "/pages/Overview/architecture.html"
  },"21": {
    "doc": "Blinky Bus Cube",
    "title": "Blinky Bus Cube",
    "content": " ",
    "url": "/pages/Installation/blinky-bus-cube.html",
    
    "relUrl": "/pages/Installation/blinky-bus-cube.html"
  },"22": {
    "doc": "Blinky Bus Cube",
    "title": "Table of contents",
    "content": ". | Overview | Building the circuit | Setting up the Bluetooth | Code Discussion | . ",
    "url": "/pages/Installation/blinky-bus-cube.html#table-of-contents",
    
    "relUrl": "/pages/Installation/blinky-bus-cube.html#table-of-contents"
  },"23": {
    "doc": "Blinky Bus Cube",
    "title": "Overview",
    "content": "Blinky-Bus is a demonstration project on how to use Blinky-Lite with serial Bluetooth to communicate between the cube and tray. The function of the device is to turn on and off three LEDs. You can obtain the source code for the cube by either cloning the repository or downloading a zip file from the green Code button on the Github page. ",
    "url": "/pages/Installation/blinky-bus-cube.html#overview",
    
    "relUrl": "/pages/Installation/blinky-bus-cube.html#overview"
  },"24": {
    "doc": "Blinky Bus Cube",
    "title": "Building the circuit",
    "content": "The project can be easily built on a breadboard, The components required are: . | One Teensy-LC micro-controller | Three LEDs | Three 220 Ohm resistors | One Bluetooth module HC-06 | One Solderless Breadboard with 400 tie-points | . Wire the circuit up as shown: . ",
    "url": "/pages/Installation/blinky-bus-cube.html#building-the-circuit",
    
    "relUrl": "/pages/Installation/blinky-bus-cube.html#building-the-circuit"
  },"25": {
    "doc": "Blinky Bus Cube",
    "title": "Setting up the Bluetooth",
    "content": "We will use the Arduino Programming environment to program the Teensy-LC. In addition to the Arduino programming environment, you will need to install Teensyduino. The next step is to set the baud rate, pin code, and name of the HC06 Bluetooth module. This step can be skipped if you are going to use 9600 baud without a pin code. However, if you do not name the device it will be difficult to find the device during the pairing process. The baud rate, pin code, and name of the HC06 are setup in the sketch contained in the folder HC06-Setup.The HC06 Bluetooth module is connected to the Serial1 port. The default baud rate of the HC06 is 9600. The baud rate on line 24 of the sketch must match this baud rate. For most Blinky-Lite applications, a baud rate of 19200 is sufficient and this is set on line 5 of the sketch. The user can choose any pin or name as long it is only 4 characters long. Open the Arduino programming environment serial monitor before loading the sketch. Choose the correct board and port under the Tools menu and load the HC06-Setup sketch. If successful, the output of the serial monitor will look like: . Once the HC06-Setup sketch is loaded onto the Teensy-LC, the HC06 Bluetooth module will only communicate at the baud rate defined on line 5 of the HC06-Setup sketch. Any further communication using the HC06-Setup sketch will require to set the baud rate appropriately on line 24. ",
    "url": "/pages/Installation/blinky-bus-cube.html#setting-up-the-bluetooth",
    
    "relUrl": "/pages/Installation/blinky-bus-cube.html#setting-up-the-bluetooth"
  },"26": {
    "doc": "Blinky Bus Cube",
    "title": "Code Discussion",
    "content": "The operating code is contained in the cubeCode.ino sketch . The baud rate is set on line 2 and must match the baud rate set in the HC06-Setup sketch. The commLEDPin sets the LED that will blink during communication exchanges between the cube and the tray. Next in lines 5-16 is a definition of shared memory between a int16_t buffer and the LED states. The first variable must be state. | A value of state=1 will signal the tray that the cube has just been initialized. | A value of state=0 means that the tray has been communicating with the cube. | The following variables are defined by the user to describe the behavior of the cube. | . The cube communicates with the tray during the blinkyBus.poll() routine. During the blinkyBus.poll() routine, the cube checks if the tray has sent any data. | If the tray has not sent any data, the blinkyBus.poll() routine exits with a return value of zero. | If the tray sends data, it must send 4 bytes of data. | The first byte is the write command. | If the write command is 0, . | then the tray has no data to give the cube | and the cube sends the entire buffer to the tray | and returns a value of 1 | . | If the write command is 1, . | Then the next byte is the index of the buffer array to be written | and the remaining two bytes are the value to be written. | The buffer is written with these two bytes at the buffer index specified. | The cube sends the entire buffer to the tray | and returns a value of 2 | . | . | . After the blinkyBus.poll(), it is possible to determine the last address and value written with the public routines: . | BlinkyBus::getLastWriteAddress() | BlinkyBus::getLastWriteValue() | . Once blinkyBus.poll() routine has been completed, the LEDs are set by current state of the buffer. ",
    "url": "/pages/Installation/blinky-bus-cube.html#code-discussion",
    
    "relUrl": "/pages/Installation/blinky-bus-cube.html#code-discussion"
  },"27": {
    "doc": "Blinky Bus Tray",
    "title": "Blinky Bus Tray",
    "content": " ",
    "url": "/pages/Installation/blinky-bus-tray.html",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html"
  },"28": {
    "doc": "Blinky Bus Tray",
    "title": "Table of contents",
    "content": ". | Overview | Preparing the Raspberry Pi | Pair the Cube | Install the Tray | Setup the environmental file | Running Node RED | Fixing the MQTT credentials | Starting the PM2 background process | Code Discussion . | The tray JSON object | User-defined flow nodes . | Create Settings Node | Create Readings node | Init Gizmo node | . | . | . ",
    "url": "/pages/Installation/blinky-bus-tray.html#table-of-contents",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#table-of-contents"
  },"29": {
    "doc": "Blinky Bus Tray",
    "title": "Overview",
    "content": "Blinky-Bus is a demonstration project on how to use Blinky-Lite with serial Bluetooth to communicate between the cube and tray. The function of the device is to turn on and off three LEDs. The Blinky-Lite tray software is written as a Node-RED flow and can easily run on a Raspberry Pi. You can obtain the source code for the cube by either cloning the repository or downloading a zip file from the green Code button on the Github page. ",
    "url": "/pages/Installation/blinky-bus-tray.html#overview",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#overview"
  },"30": {
    "doc": "Blinky Bus Tray",
    "title": "Preparing the Raspberry Pi",
    "content": "(contents) Setup an Raspberry Pi with the latest 32 bit Raspberry Pi OS Lite. It is recommended to use the Raspberry Pi Imager. Once the Raspberry Pi is up and running, SSH into the Raspberry Pi and download version 16.15.0 of Node.js . For ARM7 (Raspberry Pi 3) . wget https://nodejs.org/dist/v16.15.0/node-v16.15.0-linux-armv7l.tar.xz . For ARM6 (Raspberry Pi Zero) . wget https://unofficial-builds.nodejs.org/download/release/v16.15.0/node-v16.15.0-linux-armv6l.tar.xz . Extract the file . tar -xf node-v16.15.0-linux-armvXl.tar.xz . where X is either 6 or 7.Install the directory . cd node-v16.15.0-linux-armvXl sudo cp -R * /usr/ . where X is either 6 or 7.Check to see the version . node -v . You should see v16.15.0 Remove the installation directory . cd .. rm -rf node-v16.15.0-linux-armvXl rm node-v16.15.0-linux-armvXl.tar.xz . where X is either 6 or 7. PM2 is a handy service to run programs in background and on boot. Next install PM2 globally . sudo npm install -g pm2 . ",
    "url": "/pages/Installation/blinky-bus-tray.html#preparing-the-raspberry-pi",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#preparing-the-raspberry-pi"
  },"31": {
    "doc": "Blinky Bus Tray",
    "title": "Pair the Cube",
    "content": "(contents) Next pair the Bluetooth of the Raspberry Pi with the Bluetooth of the cube. From the Raspberry Pi: . sudo bluetoothctl . Once inside the bluetoothctl program enter: . scan on . A list of available bluetooth devices will start to be listed. Once you see the name of your HC06 device that was setup in the Blinky Bus Cube, turn the scan off: . scan off . and pair the HC06 device . pair XX:XX:XX:XX:XX:XX . where XX:XX:XX:XX:XX:XX is the MAC address of the HC06 device you saw on the scan list. The bluetoothctl program will ask you for the PIN number you setup in the Blinky Bus Cube. After you have successfully paired the HC06 device, exit the bluetoothctl program: . exit . Now you need to bind which Serial comm device for your HC06 device. At the Raspberry Pi terminal, enter: . sudo rfcomm bind 0 XX:XX:XX:XX:XX:XX . where XX:XX:XX:XX:XX:XX is the MAC address of the HC06 device. This will bind the device serial device /dev/rfcomm0 to the list of serial devices. You can see this device now by typing: . ls /dev . To remember this binding, edit the rc.local file: . sudo nano /etc/rc.local . and add the line sudo rfcomm bind 0 XX:XX:XX:XX:XX:XX right before the exit 0 line in the file. To exit the nano editor type ctrl x . ",
    "url": "/pages/Installation/blinky-bus-tray.html#pair-the-cube",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#pair-the-cube"
  },"32": {
    "doc": "Blinky Bus Tray",
    "title": "Install the Tray",
    "content": "(contents) From the Raspberry Pi terminal, clone the tray repository or download the zip file from the green Code button on the Github page. Change directory into the tray directory: . cd blinky-bus-tray . Install the code . npm install . ",
    "url": "/pages/Installation/blinky-bus-tray.html#install-the-tray",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#install-the-tray"
  },"33": {
    "doc": "Blinky Bus Tray",
    "title": "Setup the environmental file",
    "content": "(contents) The .env file contains environmental variables that should not be shared. A template file env is stored on the Github repository Copy the env file to .env file . cp env .env https://nodered.org/ The **.env** file should look like: MQTTSUBSCRIBE=blinky-lite-v4/blinky-bus/01/setting/# MQTTCLIENTID=blinky-bus-tray-01 MQTTSERVERIP=aaaa MQTTUSERNAME=bbb MQTTPASSWORD=ccc SERIALPORT=/dev/rfcomm0 SERIALBUFSIZE=8 PM2NAME=blinky-bus-01 NODEREDCONFIGSECRET=dddd . You need to change the fields aaaa, bbbb, cccc to the appropriate values for the Blinky-Lite application Box you are going to connect to. You also need to pick a unique secret for the dddd field. This secret is used to encrypt the MQTT credentials in Node-RED. ",
    "url": "/pages/Installation/blinky-bus-tray.html#setup-the-environmental-file",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#setup-the-environmental-file"
  },"34": {
    "doc": "Blinky Bus Tray",
    "title": "Running Node RED",
    "content": "(contents) Before you run Node-RED, you need to change password in the adminAuth field in the settings.js file so you will be able to view and edit the tray flow from a browser. The adminAuth field in the settings.js file is shown below. adminAuth: { type: \"credentials\", users: [{ username: \"admin\", password: \"$2a$08$KaclKnSDZ7.pGtci1ZSOIep/Dqu582RURal12L7kbJ1bnv/SYPNFq\", permissions: \"*\" }] }, . The password is encypted using bcrypt. Generate a new password using one of the many internet sites that provide encryption for passwords. To run Node-RED us the script in the tray directory ./run-blinky-lite.sh $(pwd) . Open a browser and enter into the address bar of the browser: . http://AAA.BBB.CCC.DDD:61880/admin . where AAA.BBB.CCC.DDD is the IP address of the Raspberry Pi and 61880 is the uiPort specified in the settings.js file. The browser will display: . ",
    "url": "/pages/Installation/blinky-bus-tray.html#running-node-red",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#running-node-red"
  },"35": {
    "doc": "Blinky Bus Tray",
    "title": "Fixing the MQTT credentials",
    "content": "(contents) Enter the username and password defined in the adminAuth block of settings.js You will most likely see the following screen with an error message that the credentials could not be decrypted . Close the error message and on the right hand side of the screen is an info panel. | Expand the Global Configuration Nodes tree item, | and then expand the mqtt-broker tree item. | Next double click on the MQTT Broker icon | and select the Security menu of the Edit mqtt-broker node panel that slid open | To pickup the environmental variables specified in the .env file, enter: . | $(MQTTUSERNAME) in the Username box | $(MQTTPASSWORD) in the Password box | . | . | Press the Update button to close Edit mqtt-broker node panel | Press the Deploy button to load the flow. | . The flow should be working with green boxes underneath the light purple MQTT nodes indicating that they are connected. ",
    "url": "/pages/Installation/blinky-bus-tray.html#fixing-the-mqtt-credentials",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#fixing-the-mqtt-credentials"
  },"36": {
    "doc": "Blinky Bus Tray",
    "title": "Starting the PM2 background process",
    "content": "(contents) Return to the terminal on the Raspberry Pi and terminate the Node-RED script by typing ctrl c. Start the PM2 script to run Node-RED in background: ./pm2.sh $(pwd) . Save the PM2 state of the Raspberry Pi: . pm2 save . To have the PM2 process start at boot: . pm2 startup systemd . The command will return with a command to paste that looks like: . sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/pi . Paste and execute the command. Now the tray will start automatically on boot. ",
    "url": "/pages/Installation/blinky-bus-tray.html#starting-the-pm2-background-process",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#starting-the-pm2-background-process"
  },"37": {
    "doc": "Blinky Bus Tray",
    "title": "Code Discussion",
    "content": "The tray JSON object . (contents) The purpose of the Blinky-Lite tray is to package the data coming from the cube and send this data to the application box. Instead of sending many name-value pairs, the tray packages all of the cube data into a single JSON object. The definition of the tray JSON object is defined in the tray.json file. | Trays with the same type should behave the same way. | The name value distinguishes trays of the same type . | Note that the type and name must match the MQTTSUBSCRIBE environmental variable | . | The arcPeriod defines how often (in milli Seconds) the application box should archive the tray. | The timeStamp will be used by the application box to time stamp the tray data. It is in JavaScript millSeconds since Jan 1 1970. | The watchdog is an optional cube object that the tray can increment to indicate the tray is functioning. | The linkQuality and signalLevel are optional cube objects that describe the strength of the wireless signal of the Raspberry Pi determined by iwconfig. | The ledX cube objects are specific to the cube and describe the LED’s behavior. | The action determines if it is a reading or a setting | The type can be scalar (single number), vector [[],[]], or text | The value and unit are self explanatory | The alarm object is for scalar data types . | an alarm value of 0 means the cube value is between low and high limits | an alarm value of 1 means the cube value is less than the low limit | an alarm value of 2 means the cube value is greater than the high limit | an alarm value of 3 means the cube value is less than the low limit | an alarm value of 4 means the cube value is greater than the hihi limit | The notify object is used by the application box to send an SMS if there is an alarm | . | . | . User-defined flow nodes . (contents) In the Node-RED flow there are three nodes where the user can customize how the tray behaves and not disturb any of the background communication functionality. | Create Setting node | Create Readings node | Init Gizmo node | . These nodes are easily identified with a purple background and a yellow Edit Me label. Create Settings Node . (contents) The Create Settings Node listens to the MQTT topic defined by the MQTTSUBSCRIBE environmental variable. The # wild card at the end of the MQTTSUBSCRIBE topic can take on four values . | setting . | for setting a cube scalar value | . | ping . | will echo the tray back to the MQTT broker immediately | . | config . | to change the alarm configuration of a scalar cube | . | reset . | will reset the node-red tray process | . | . For the setting process the MQTT payload must be of the form . {cube:cube_name, value:x} . where x is an number or a string. The user must edit the Create Setting node to setup up the behavior of the setting as shown below. The settings can be of two types: . | blinkyBus settings . | in which the user must specify the address of the blinkyBus setting. | the setting is then routed to the BlinkyBus serial port. | the setting value must be an integer | . | non-blinkyBus settings . | the user can do anything with the setting such as setting a cube object in a tray | or other functionality | . | . Create Readings node . (contents) The Create Readings node takes data from BlinkyBus and populates the tray cub objects. Init Gizmo node . (contents) If the cube device returns a state value of 1, such as when the cube device is powered up, this node will be triggered and the node defines how the cube device should be initially configured . ",
    "url": "/pages/Installation/blinky-bus-tray.html#code-discussion",
    
    "relUrl": "/pages/Installation/blinky-bus-tray.html#code-discussion"
  },"38": {
    "doc": "Cube Explorer App",
    "title": "Cube Explorer",
    "content": "The Cube Explorer App is the Swiss army knife application of Blinky-LiteTM. As described in the Architecture Overview, Blinky-LiteTM stores device data in a JSON object called a tray. Name-value pairs inside the tray are called cubes. Besides storing values, each cube also contains a unit description and an alarm block. The Cube Explorer is a user configurable app to read and/or set any combination of cubes from any set of trays that the user has access rights to view. The app also permits the user to set the alarm block configuration of the cube. The user can plot real time data from the cubes or look at the archived history of the cubes. The archived history can also be downloaded into csv format files for off-line analysis. The user can also save multiple personalized cube configurations. ",
    "url": "/pages/Overview/cubeExplorerAppPreview.html#cube-explorer",
    
    "relUrl": "/pages/Overview/cubeExplorerAppPreview.html#cube-explorer"
  },"39": {
    "doc": "Cube Explorer App",
    "title": "Cube Explorer App",
    "content": " ",
    "url": "/pages/Overview/cubeExplorerAppPreview.html",
    
    "relUrl": "/pages/Overview/cubeExplorerAppPreview.html"
  },"40": {
    "doc": "Features",
    "title": "Blinky-LiteTM Features",
    "content": ". | ",
    "url": "/pages/Overview/features.html#blinky-litetm-features",
    
    "relUrl": "/pages/Overview/features.html#blinky-litetm-features"
  },"41": {
    "doc": "Features",
    "title": "Mobility",
    "content": "Most other control platforms sit behind a firewall and remote access is an afterthought. Not with Blinky-LiteTM. Secure remote access was the paramount requirement from the start. All Blinky-LiteTM applications are web apps that can be securely accessed from anywhere in the world. Web apps require no installation and you are always guaranteed to get the latest version. | ",
    "url": "/pages/Overview/features.html#mobility",
    
    "relUrl": "/pages/Overview/features.html#mobility"
  },"42": {
    "doc": "Features",
    "title": "Security",
    "content": "Blinky-LiteTM connections are always initiated from within your facility, not from the outside, providing secure information flow from you to the machine/sensor and back. All Blinky-LiteTM mobile apps require two factor authentication, ensuring that only the right people have access. | ",
    "url": "/pages/Overview/features.html#security",
    
    "relUrl": "/pages/Overview/features.html#security"
  },"43": {
    "doc": "Features",
    "title": "Flexibility",
    "content": "Blinky-LiteTM can be added independently or on top of any existing control system . | ",
    "url": "/pages/Overview/features.html#flexibility",
    
    "relUrl": "/pages/Overview/features.html#flexibility"
  },"44": {
    "doc": "Features",
    "title": "Open source",
    "content": "Every single line of the Blinky-LiteTM codebase is version-controlled and open allowing Blinky-LiteTM to grow with you. | No license fees | No proprietary software | . | ",
    "url": "/pages/Overview/features.html#open-source",
    
    "relUrl": "/pages/Overview/features.html#open-source"
  },"45": {
    "doc": "Features",
    "title": "Services",
    "content": "Most other control platforms only offer a communication protocol, but Blinky-LiteTM out of the box provides: . | Alarm Scanning | SMS Alarm messaging | Data Logging | Access Logging | Settings Logging | Application role based access | Data stream role based access | Zero-code application builder | Device-side restricted messaging | Scalar plotting | Vector plotting | User customized app launcher | User customized device viewers | Two factor authentication | . | . ",
    "url": "/pages/Overview/features.html#services",
    
    "relUrl": "/pages/Overview/features.html#services"
  },"46": {
    "doc": "Features",
    "title": "Features",
    "content": " ",
    "url": "/pages/Overview/features.html",
    
    "relUrl": "/pages/Overview/features.html"
  },"47": {
    "doc": "Overview",
    "title": "Blinky-LiteTM",
    "content": "Blinky-LiteTM is a full-stack, integrated hardware-software control platform based on Edge computing technology designed by hardware engineers that can perform at any scale from home automation to particle accelerators. Blinky-LiteTM was developed at the MaxIV Synchrotron Light Source and the European Spallation Source both located in Lund, Sweden. In this world of complex and costly particle accelerators, a strong 24/7 maintenance mindset is a must. It is essential to always understand the state of a machine remotely and to be able to securely troubleshoot it efficiently from anywhere in the world at any time. That’s why we developed Blinky-LiteTM . ",
    "url": "/#blinky-litetm",
    
    "relUrl": "/#blinky-litetm"
  },"48": {
    "doc": "Overview",
    "title": "Overview",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"49": {
    "doc": "Installation",
    "title": "Installation Overview",
    "content": " ",
    "url": "/pages/Installation/installOverview.html#installation-overview",
    
    "relUrl": "/pages/Installation/installOverview.html#installation-overview"
  },"50": {
    "doc": "Installation",
    "title": "Installation",
    "content": " ",
    "url": "/pages/Installation/installOverview.html",
    
    "relUrl": "/pages/Installation/installOverview.html"
  },"51": {
    "doc": "MyApps",
    "title": "MyApps",
    "content": ". With many control systems, the user can be overwhelmed by the number of applications to use. This is solved in Blinky-LiteTM by having a personalize launcher app for each user. The MyApps application is configured for each user with a JSON file in the database as shown below. ",
    "url": "/pages/Overview/myAppsPreview.html",
    
    "relUrl": "/pages/Overview/myAppsPreview.html"
  },"52": {
    "doc": "Role Based Access",
    "title": "Role Based Access",
    "content": "App authentication is used to keep intruders out of a Blinky-LiteTM control system which is very important. However, making sure that authenticated users do not do something unintentionally is probably more critical. In Blinky-LiteTM, this accomplished with role-based-access. Most control systems implement only reading and setting privileges but with Blinky-LiteTM is possible to restrict not only what actions are permitted by what applications are allowed to be accessed. In addition, because Blinky-LiteTM groups data into message trays, it is also possible to restrict which data a user has access to as well. Below shows an example user profile for Blinky-LiteTM role-based-access. ",
    "url": "/pages/Overview/roleBasedAccess.html",
    
    "relUrl": "/pages/Overview/roleBasedAccess.html"
  },"53": {
    "doc": "Settings Log App",
    "title": "Settings Log",
    "content": "The settings log shows the what cube values have been changed over a particular interval of time. Only cubes that a particular user has access to are displayed for that use. ",
    "url": "/pages/Overview/settingsLogAppPreview.html#settings-log",
    
    "relUrl": "/pages/Overview/settingsLogAppPreview.html#settings-log"
  },"54": {
    "doc": "Settings Log App",
    "title": "Settings Log App",
    "content": " ",
    "url": "/pages/Overview/settingsLogAppPreview.html",
    
    "relUrl": "/pages/Overview/settingsLogAppPreview.html"
  },"55": {
    "doc": "App Style Sheets",
    "title": "App Style Sheets",
    "content": " ",
    "url": "/pages/Overview/styleSheets.html",
    
    "relUrl": "/pages/Overview/styleSheets.html"
  },"56": {
    "doc": "App Style Sheets",
    "title": "Application Examples",
    "content": "Every application in a Blinky-LiteTM project can have its own cascading style sheet (CSS) to define the look and feel of the application. These style sheets are stored in the database as a JSON object. There can be as many style sheets as the user would like and a given style sheet can be shared by a number of applications. | Example 1 | Example 2 | . | | | . ",
    "url": "/pages/Overview/styleSheets.html#application-examples",
    
    "relUrl": "/pages/Overview/styleSheets.html#application-examples"
  },"57": {
    "doc": "App Style Sheets",
    "title": "App Style Sheet JSON",
    "content": ". ",
    "url": "/pages/Overview/styleSheets.html#app-style-sheet-json",
    
    "relUrl": "/pages/Overview/styleSheets.html#app-style-sheet-json"
  }
}
